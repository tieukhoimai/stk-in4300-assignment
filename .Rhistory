}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(vtable)
# Download the dataset
download.file('https://archive.ics.uci.edu/static/public/275/bike+sharing+dataset.zip',
'bike-sharing.zip')
unzip('bike-sharing.zip', files = 'day.csv')
# Load the dataset
df <- read.csv('day.csv', header = TRUE)
# Remove zip and csv files
file.remove(list.files(pattern = "\\.zip$|\\.csv$"))
st(df)
ggplot(df, aes(x = factor(1), fill = factor(season))) +
geom_bar(width = 1) +
coord_polar(theta = "y") +
labs(title = "Pie Chart of Total Bike Rentals by Season", fill = "Season")
ggplot(df, aes(x = temp, y = cnt)) +
geom_line(color = "blue") +
labs(title = "Total Bike Rentals by Temperature",
x = "Temperature (Normalized)",
y = "Total Bike Rentals")
ggplot(df, aes(x = factor(season), y = cnt, fill = factor(season))) +
geom_bar(stat = "summary", fun = "sum") +
labs(title = "Total Bike Rentals by Season",
x = "Season",
y = "Total Bike Rentals",
fill = "Season")
ggplot(data = df, aes(x = temp, y = cnt)) +
geom_point(alpha = 0.3) +
geom_smooth(formula = y ~ x, method = "loess", color = "red", se = FALSE) +
labs(title = "Total Bike Rentals by Temperature",
x = "Temperature (Normalized)",
y = "Total Bike Rentals")
y <- df$cnt
X <- df[, c('season', 'yr', 'mnth', 'hr', 'holiday', 'weekday', 'workingday',
'weathersit', 'temp', 'atemp', 'hum', 'windspeed')]
df
y <- df$cnt
X <- df[, c('season', 'mnth', 'holiday', 'weekday', 'workingday',
'weathersit', 'temp', 'atemp', 'hum', 'windspeed')]
cor(X)
full.model <- lm(y ~ ., data = X)
summary(full.model)
library(MASS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
summary(model.backward.aic)
model.forward.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'forward')
summary(model.forward.aic)
model.stepwise.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'both')
summary(model.stepwise.aic)
num_vars <- ncol(X)
allCombinations <- sapply(1:num_vars, function(m) combn(x = 1:num_vars, m = m))
null.model <- lm(y ~ 1)
result.AIC <- extractAIC(null.model)
result.RSS <- cbind(1, deviance(null.model))
for (i in 1:num_vars) {  # For each number of variables
for (j in 1:ncol(allCombinations[[i]])) {  # For each subset of size 'i'
# Fit model using current subset of variables
model <- lm(y ~ ., data = as.data.frame(X[, allCombinations[[i]][, j]]))
# Store AIC and RSS for this model
result.AIC <- rbind(result.AIC, extractAIC(model))
result.RSS <- rbind(result.RSS, cbind(length(allCombinations[[i]][, j]), deviance(model)))
}
}
# Plot RSS for all subset sizes
plot(result.RSS[, 1], result.RSS[, 2], main = 'Residual Sum of Squares for Subsets',
xlab = 'Subset size', ylab = 'Residual Sum of Squares (RSS)')
# identify the model with the smallest RSS
best.RSS <- result.RSS[which.min(result.RSS[, 2]), ]
index <- which.min(result.RSS[result.RSS[, 1] == best.RSS[1], 2])
variables.best.model <- allCombinations[[best.RSS[1]]][, index]
# final model
model.bestSubset.RSS <- lm(y ~ ., data = as.data.frame(X[, variables.best.model]))
summary(model.bestSubset.RSS)
# Forward Selection
null.model <- lm(y ~ 1, data = as.data.frame(X))
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Selection
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
plot(0, 0, xlim = c(1, num_vars), ylim = c(min(rss1, rss2, rss3), max(rss1, rss2, rss3)),
type = "n", xlab = "Number of Variables", ylab = "Residual Sum of Squares (RSS)")
lines(1:num_vars, rss1, col = "red", type = 'p', pch = 16, lty = 1)  # Forward
lines(1:num_vars, rss2, col = "green", type = 'p', pch = 16, lty = 2)  # Backward
lines(1:num_vars, rss3, col = "blue", type = 'p', pch = 16, lty = 3)  #Should be the minimum given that we are exploring all possible combinations
legend("topright", legend = c("Forward", "Backward", "Best Subset"), col = c("red", "green", "blue"), pch = 16)
null.model <- lm(y ~ 1)
full.model <- lm(y ~ .)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
# Forward Selection
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Selection
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
plot(0, 0, xlim = c(1, num_vars), ylim = c(min(rss1, rss2, rss3), max(rss1, rss2, rss3)),
type = "n", xlab = "Number of Variables", ylab = "Residual Sum of Squares (RSS)")
lines(1:num_vars, rss1, col = "red", type = 'p', pch = 16, lty = 1)  # Forward
lines(1:num_vars, rss2, col = "green", type = 'p', pch = 16, lty = 2)  # Backward
lines(1:num_vars, rss3, col = "blue", type = 'p', pch = 16, lty = 3)  #Should be the minimum given that we are exploring all possible combinations
legend("topright", legend = c("Forward", "Backward", "Best Subset"), col = c("red", "green", "blue"), pch = 16)
library(MASS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
library(MASS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
summary(model.backward.aic)
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
summary(model.backward.aic)
model.forward.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'forward')
summary(model.forward.aic)
model.stepwise.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'both')
summary(model.stepwise.aic)
num_vars <- ncol(X)
allCombinations <- sapply(1:num_vars, function(m) combn(x = 1:num_vars, m = m))
null.model <- lm(y ~ 1)
result.AIC <- extractAIC(null.model)
result.RSS <- cbind(1, deviance(null.model))
for (i in 1:num_vars) {  # For each number of variables
for (j in 1:ncol(allCombinations[[i]])) {  # For each subset of size 'i'
# Fit model using current subset of variables
model <- lm(y ~ ., data = as.data.frame(X[, allCombinations[[i]][, j]]))
# Store AIC and RSS for this model
result.AIC <- rbind(result.AIC, extractAIC(model))
result.RSS <- rbind(result.RSS, cbind(length(allCombinations[[i]][, j]), deviance(model)))
}
}
# Plot RSS for all subset sizes
plot(result.RSS[, 1], result.RSS[, 2], main = 'Residual Sum of Squares for Subsets',
xlab = 'Subset size', ylab = 'Residual Sum of Squares (RSS)')
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
# Forward Selection
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Selection
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
plot(0, 0, xlim = c(1, num_vars), ylim = c(min(rss1, rss2, rss3), max(rss1, rss2, rss3)),
type = "n", xlab = "Number of Variables", ylab = "Residual Sum of Squares (RSS)")
lines(1:num_vars, rss1, col = "red", type = 'p', pch = 16, lty = 1)  # Forward
lines(1:num_vars, rss2, col = "green", type = 'p', pch = 16, lty = 2)  # Backward
lines(1:num_vars, rss3, col = "blue", type = 'p', pch = 16, lty = 3)  #Should be the minimum given that we are exploring all possible combinations
legend("topright", legend = c("Forward", "Backward", "Best Subset"), col = c("red", "green", "blue"), pch = 16)
str(df)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(vtable)
# Download the dataset
download.file('https://archive.ics.uci.edu/static/public/275/bike+sharing+dataset.zip',
'bike-sharing.zip')
unzip('bike-sharing.zip', files = 'day.csv')
# Load the dataset
df <- read.csv('day.csv', header = TRUE)
# Remove zip and csv files
file.remove(list.files(pattern = "\\.zip$|\\.csv$"))
st(df)
ggplot(df, aes(x = factor(1), fill = factor(season))) +
geom_bar(width = 1) +
coord_polar(theta = "y") +
labs(title = "Pie Chart of Total Bike Rentals by Season", fill = "Season")
ggplot(df, aes(x = temp, y = cnt)) +
geom_line(color = "blue") +
labs(title = "Total Bike Rentals by Temperature",
x = "Temperature (Normalized)",
y = "Total Bike Rentals")
ggplot(df, aes(x = factor(season), y = cnt, fill = factor(season))) +
geom_bar(stat = "summary", fun = "sum") +
labs(title = "Total Bike Rentals by Season",
x = "Season",
y = "Total Bike Rentals",
fill = "Season")
ggplot(data = df, aes(x = temp, y = cnt)) +
geom_point(alpha = 0.3) +
geom_smooth(formula = y ~ x, method = "loess", color = "red", se = FALSE) +
labs(title = "Total Bike Rentals by Temperature",
x = "Temperature (Normalized)",
y = "Total Bike Rentals")
y <- df$cnt
X <- df[, c('season', 'mnth', 'holiday', 'weekday', 'workingday',
'weathersit', 'temp', 'atemp', 'hum', 'windspeed')]
cor(X)
full.model <- lm(y ~ ., data = X)
summary(full.model)
library(MASS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
summary(model.backward.aic)
model.forward.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'forward')
summary(model.forward.aic)
model.stepwise.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'both')
summary(model.stepwise.aic)
num_vars <- ncol(X)
allCombinations <- sapply(1:num_vars, function(m) combn(x = 1:num_vars, m = m))
null.model <- lm(y ~ 1)
result.AIC <- extractAIC(null.model)
result.RSS <- cbind(1, deviance(null.model))
for (i in 1:num_vars) {  # For each number of variables
for (j in 1:ncol(allCombinations[[i]])) {  # For each subset of size 'i'
# Fit model using current subset of variables
model <- lm(y ~ ., data = as.data.frame(X[, allCombinations[[i]][, j]]))
# Store AIC and RSS for this model
result.AIC <- rbind(result.AIC, extractAIC(model))
result.RSS <- rbind(result.RSS, cbind(length(allCombinations[[i]][, j]), deviance(model)))
}
}
# Plot RSS for all subset sizes
plot(result.RSS[, 1], result.RSS[, 2], main = 'Residual Sum of Squares for Subsets',
xlab = 'Subset size', ylab = 'Residual Sum of Squares (RSS)')
# identify the model with the smallest RSS
best.RSS <- result.RSS[which.min(result.RSS[, 2]), ]
index <- which.min(result.RSS[result.RSS[, 1] == best.RSS[1], 2])
variables.best.model <- allCombinations[[best.RSS[1]]][, index]
# final model
model.bestSubset.RSS <- lm(y ~ ., data = as.data.frame(X[, variables.best.model]))
summary(model.bestSubset.RSS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
# Forward Selection
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Selection
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
plot(0, 0, xlim = c(1, num_vars), ylim = c(min(rss1, rss2, rss3), max(rss1, rss2, rss3)),
type = "n", xlab = "Number of Variables", ylab = "Residual Sum of Squares (RSS)")
lines(1:num_vars, rss1, col = "red", type = 'p', pch = 16, lty = 1)  # Forward
lines(1:num_vars, rss2, col = "green", type = 'p', pch = 16, lty = 2)  # Backward
lines(1:num_vars, rss3, col = "blue", type = 'p', pch = 16, lty = 3)  #Should be the minimum given that we are exploring all possible combinations
legend("topright", legend = c("Forward", "Backward", "Best Subset"), col = c("red", "green", "blue"), pch = 16)
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
summary(model.backward.aic)
model.forward.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'forward')
summary(model.forward.aic)
```{r echo=FALSE}
model.stepwise.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'both')
summary(model.stepwise.aic)
num_vars <- ncol(X)
allCombinations <- sapply(1:num_vars, function(m) combn(x = 1:num_vars, m = m))
null.model <- lm(y ~ 1)
result.AIC <- extractAIC(null.model)
result.RSS <- cbind(1, deviance(null.model))
for (i in 1:num_vars) {  # For each number of variables
for (j in 1:ncol(allCombinations[[i]])) {  # For each subset of size 'i'
# Fit model using current subset of variables
model <- lm(y ~ ., data = as.data.frame(X[, allCombinations[[i]][, j]]))
# Store AIC and RSS for this model
result.AIC <- rbind(result.AIC, extractAIC(model))
result.RSS <- rbind(result.RSS, cbind(length(allCombinations[[i]][, j]), deviance(model)))
}
}
# Plot RSS for all subset sizes
plot(result.RSS[, 1], result.RSS[, 2], main = 'Residual Sum of Squares for Subsets',
xlab = 'Subset size', ylab = 'Residual Sum of Squares (RSS)')
# identify the model with the smallest RSS
best.RSS <- result.RSS[which.min(result.RSS[, 2]), ]
index <- which.min(result.RSS[result.RSS[, 1] == best.RSS[1], 2])
variables.best.model <- allCombinations[[best.RSS[1]]][, index]
# final model
model.bestSubset.RSS <- lm(y ~ ., data = as.data.frame(X[, variables.best.model]))
summary(model.bestSubset.RSS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
# Forward Selection
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Elimination
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
# Forward Selection
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Elimination
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
plot(0, 0, xlim = c(1, num_vars), ylim = c(min(rss1, rss2, rss3), max(rss1, rss2, rss3)),
type = "n", xlab = "Number of Variables", ylab = "Residual Sum of Squares (RSS)")
lines(1:num_vars, rss1, col = "red", type = 'p', pch = 16, lty = 1)  # Forward
lines(1:num_vars, rss2, col = "green", type = 'p', pch = 16, lty = 2)  # Backward
lines(1:num_vars, rss3, col = "blue", type = 'p', pch = 16, lty = 3)  #Should be the minimum given that we are exploring all possible combinations
legend("topright", legend = c("Forward", "Backward", "Best Subset"), col = c("red", "green", "blue"), pch = 16)
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(vtable)
# Download the dataset
download.file('https://archive.ics.uci.edu/static/public/275/bike+sharing+dataset.zip',
'bike-sharing.zip')
unzip('bike-sharing.zip', files = 'day.csv')
# Load the dataset
df <- read.csv('day.csv', header = TRUE)
# Remove zip and csv files
file.remove(list.files(pattern = "\\.zip$|\\.csv$"))
st(df)
ggplot(df, aes(x = factor(1), fill = factor(season))) +
geom_bar(width = 1) +
coord_polar(theta = "y") +
labs(title = "Pie Chart of Total Bike Rentals by Season", fill = "Season")
ggplot(df, aes(x = temp, y = cnt)) +
geom_line(color = "blue") +
labs(title = "Total Bike Rentals by Temperature",
x = "Temperature (Normalized)",
y = "Total Bike Rentals")
ggplot(df, aes(x = factor(season), y = cnt, fill = factor(season))) +
geom_bar(stat = "summary", fun = "sum") +
labs(title = "Total Bike Rentals by Season",
x = "Season",
y = "Total Bike Rentals",
fill = "Season")
ggplot(data = df, aes(x = temp, y = cnt)) +
geom_point(alpha = 0.3) +
geom_smooth(formula = y ~ x, method = "loess", color = "red", se = FALSE) +
labs(title = "Total Bike Rentals by Temperature",
x = "Temperature (Normalized)",
y = "Total Bike Rentals")
y <- df$cnt
X <- df[, c('season', 'mnth', 'holiday', 'weekday', 'workingday',
'weathersit', 'temp', 'atemp', 'hum', 'windspeed')]
cor(X)
full.model <- lm(y ~ ., data = X)
summary(full.model)
library(MASS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
summary(model.backward.aic)
model.forward.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'forward')
summary(model.forward.aic)
model.stepwise.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'both')
summary(model.stepwise.aic)
num_vars <- ncol(X)
allCombinations <- sapply(1:num_vars, function(m) combn(x = 1:num_vars, m = m))
null.model <- lm(y ~ 1)
result.AIC <- extractAIC(null.model)
result.RSS <- cbind(1, deviance(null.model))
for (i in 1:num_vars) {  # For each number of variables
for (j in 1:ncol(allCombinations[[i]])) {  # For each subset of size 'i'
# Fit model using current subset of variables
model <- lm(y ~ ., data = as.data.frame(X[, allCombinations[[i]][, j]]))
# Store AIC and RSS for this model
result.AIC <- rbind(result.AIC, extractAIC(model))
result.RSS <- rbind(result.RSS, cbind(length(allCombinations[[i]][, j]), deviance(model)))
}
}
# Plot RSS for all subset sizes
plot(result.RSS[, 1], result.RSS[, 2], main = 'Residual Sum of Squares for Subsets',
xlab = 'Subset size', ylab = 'Residual Sum of Squares (RSS)')
# identify the model with the smallest RSS
best.RSS <- result.RSS[which.min(result.RSS[, 2]), ]
index <- which.min(result.RSS[result.RSS[, 1] == best.RSS[1], 2])
variables.best.model <- allCombinations[[best.RSS[1]]][, index]
# final model
model.bestSubset.RSS <- lm(y ~ ., data = as.data.frame(X[, variables.best.model]))
summary(model.bestSubset.RSS)
full.model <- lm(y ~ ., data = as.data.frame(X))
null.model <- lm(y ~ 1, data = as.data.frame(X))
# Forward Selection
scp <- full.model$terms
rss1 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = null.model, scope = scp, direction =
'forward', k = 0, steps = j)
rss1[j] <- sum((mdl$fitted.values-y)^2)
}
# Backward Elimination
rss2 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
mdl <- stepAIC(object = full.model, scope = list(lower = null.model, upper = full.model),
direction = 'backward', k = 1e6, steps = j-1)
rss2[j] <- sum((mdl$fitted.values - y)^2)
}
rss2 <- rev(rss2)
# Best Subset Selection
rss3 <- vector("numeric", num_vars)
for (j in 1:num_vars) {
rss3[j] <- min(result.RSS[result.RSS[, 1] == j, 2])
}
plot(0, 0, xlim = c(1, num_vars), ylim = c(min(rss1, rss2, rss3), max(rss1, rss2, rss3)),
type = "n", xlab = "Number of Variables", ylab = "Residual Sum of Squares (RSS)")
lines(1:num_vars, rss1, col = "red", type = 'p', pch = 16, lty = 1)  # Forward
lines(1:num_vars, rss2, col = "green", type = 'p', pch = 16, lty = 2)  # Backward
lines(1:num_vars, rss3, col = "blue", type = 'p', pch = 16, lty = 3)  #Should be the minimum given that we are exploring all possible combinations
legend("topright", legend = c("Forward", "Backward", "Best Subset"), col = c("red", "green", "blue"), pch = 16)
model.backward.aic <- stepAIC(object = full.model, scope = null.model, direction = 'backward')
cor(X)
num_vars <- ncol(X)
allCombinations <- sapply(1:num_vars, function(m) combn(x = 1:num_vars, m = m))
null.model <- lm(y ~ 1)
result.AIC <- extractAIC(null.model)
result.RSS <- cbind(1, deviance(null.model))
for (i in 1:num_vars) {  # For each number of variables
for (j in 1:ncol(allCombinations[[i]])) {  # For each subset of size 'i'
# Fit model using current subset of variables
model <- lm(y ~ ., data = as.data.frame(X[, allCombinations[[i]][, j]]))
# Store AIC and RSS for this model
result.AIC <- rbind(result.AIC, extractAIC(model))
result.RSS <- rbind(result.RSS, cbind(length(allCombinations[[i]][, j]), deviance(model)))
}
}
# Plot RSS for all subset sizes
plot(result.RSS[, 1], result.RSS[, 2], main = 'Residual Sum of Squares for Subsets',
xlab = 'Subset size', ylab = 'Residual Sum of Squares (RSS)')
model.forward.aic <- stepAIC(object = null.model, scope = full.model$terms, direction = 'forward')
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(vtable)
# Download the dataset
download.file('https://archive.ics.uci.edu/static/public/275/bike+sharing+dataset.zip',
'bike-sharing.zip')
unzip('bike-sharing.zip', files = 'day.csv')
# Load the dataset
df <- read.csv('day.csv', header = TRUE)
